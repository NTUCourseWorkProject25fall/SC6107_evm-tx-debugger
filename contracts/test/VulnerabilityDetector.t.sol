// SPDX-License-Identifier: MIT
pragma solidity ^0.8.23;

import {Test, console} from "forge-std/Test.sol";
import {VulnerabilityDetector} from "../src/analyzer/VulnerabilityDetector.sol";
import {TraceAnalyzer} from "../src/analyzer/TraceAnalyzer.sol";
import {StateDiffAnalyzer} from "../src/analyzer/StateDiffAnalyzer.sol";
import {TestContracts} from "../src/test/TestContracts.sol";

contract VulnerabilityDetectorTest is Test {
    using VulnerabilityDetector for TraceAnalyzer.CallInfo[];
    
    TestContracts.VulnerableContract public vulnerableContract;
    TestContracts.SafeContract public safeContract;
    
    function setUp() public {
        vulnerableContract = new TestContracts.VulnerableContract();
        safeContract = new TestContracts.SafeContract();
    }
    
    function testDetectReentrancy() public {
        vm.deal(address(this), 10 ether);
        vulnerableContract.deposit{value: 1 ether}();
        
        TraceAnalyzer.CallInfo[] memory calls = new TraceAnalyzer.CallInfo[](2);
        
        bytes memory withdrawData = abi.encodeWithSignature("withdraw(uint256)", 0.5 ether);
        calls[0] = TraceAnalyzer.analyzeCall(
            address(this),
            address(vulnerableContract),
            0,
            withdrawData,
            85000,
            true
        );
        calls[0].callType = TraceAnalyzer.CallType.CALL;
        calls[0].value = 0.5 ether;
        
        // Simulate state change after call
        StateDiffAnalyzer.StateDiff memory stateDiff;
        stateDiff.storageChanges = new StateDiffAnalyzer.StorageChange[](1);
        stateDiff.storageChanges[0] = StateDiffAnalyzer.recordStorageChange(
            address(vulnerableContract),
            keccak256(abi.encode(address(this), uint256(0))),
            bytes32(uint256(1 ether)),
            bytes32(uint256(0.5 ether))
        );
        
        VulnerabilityDetector.Vulnerability memory vuln = VulnerabilityDetector.detectReentrancy(
            calls,
            stateDiff
        );
        
        // Should detect reentrancy pattern
        assertEq(vuln.id, "REENTRANCY");
        assertEq(uint256(vuln.severity), uint256(VulnerabilityDetector.Severity.HIGH));
    }
    
    function testDetectUncheckedCalls() public {
        TraceAnalyzer.CallInfo[] memory calls = new TraceAnalyzer.CallInfo[](1);
        
        bytes memory data = abi.encodeWithSignature("unsafeCall(address,bytes)", address(0x1), "");
        calls[0] = TraceAnalyzer.analyzeCall(
            address(this),
            address(vulnerableContract),
            1 ether,
            data,
            50000,
            false // Failed call
        );
        calls[0].callType = TraceAnalyzer.CallType.CALL;
        
        VulnerabilityDetector.Vulnerability memory vuln = VulnerabilityDetector.detectUncheckedCalls(calls);
        
        assertEq(vuln.id, "UNCHECKED_CALL");
        assertEq(uint256(vuln.severity), uint256(VulnerabilityDetector.Severity.MEDIUM));
    }
    
    function testDetectDangerousDelegatecall() public {
        TraceAnalyzer.CallInfo[] memory calls = new TraceAnalyzer.CallInfo[](1);
        
        bytes memory data = abi.encodeWithSignature("dangerousDelegatecall(address,bytes)", address(0x1), "");
        calls[0] = TraceAnalyzer.analyzeCall(
            address(this),
            address(vulnerableContract),
            0,
            data,
            50000,
            true
        );
        calls[0].callType = TraceAnalyzer.CallType.DELEGATECALL;
        
        VulnerabilityDetector.Vulnerability memory vuln = VulnerabilityDetector.detectDangerousDelegatecall(calls);
        
        assertEq(vuln.id, "DELEGATECALL");
        assertEq(uint256(vuln.severity), uint256(VulnerabilityDetector.Severity.CRITICAL));
        assertGt(vuln.occurrenceCount, 0);
    }
    
    function testDetectAccessControlIssues() public {
        TraceAnalyzer.CallInfo[] memory calls = new TraceAnalyzer.CallInfo[](1);
        
        bytes memory data = abi.encodeWithSignature("setOwner(address)", address(0x1));
        calls[0] = TraceAnalyzer.analyzeCall(
            address(this),
            address(vulnerableContract),
            0,
            data,
            50000,
            true
        );
        
        StateDiffAnalyzer.StateDiff memory stateDiff;
        stateDiff.storageChanges = new StateDiffAnalyzer.StorageChange[](1);
        // Owner storage slot (simplified - in production would use proper slot calculation)
        stateDiff.storageChanges[0] = StateDiffAnalyzer.recordStorageChange(
            address(vulnerableContract),
            bytes32(uint256(1)), // owner slot
            bytes32(uint256(uint160(address(this)))),
            bytes32(uint256(uint160(address(0x1))))
        );
        
        VulnerabilityDetector.Vulnerability memory vuln = VulnerabilityDetector.detectAccessControlIssues(
            calls,
            stateDiff
        );
        
        assertEq(vuln.id, "ACCESS_CONTROL");
        assertEq(uint256(vuln.severity), uint256(VulnerabilityDetector.Severity.MEDIUM));
    }
    
    function testDetectIntegerOverflow() public {
        StateDiffAnalyzer.StateDiff memory stateDiff;
        stateDiff.balanceChanges = new StateDiffAnalyzer.BalanceChange[](1);
        
        // Large balance change that might indicate overflow
        stateDiff.balanceChanges[0] = StateDiffAnalyzer.recordBalanceChange(
            address(this),
            0,
            type(uint128).max + 1
        );
        
        VulnerabilityDetector.Vulnerability memory vuln = VulnerabilityDetector.detectIntegerOverflow(stateDiff);
        
        assertEq(vuln.id, "INTEGER_OVERFLOW");
        assertGt(vuln.occurrenceCount, 0);
    }
    
    function testAnalyzeVulnerabilities() public {
        vm.deal(address(this), 10 ether);
        vulnerableContract.deposit{value: 1 ether}();
        
        TraceAnalyzer.CallInfo[] memory calls = new TraceAnalyzer.CallInfo[](2);
        
        // Delegatecall
        bytes memory delegatecallData = abi.encodeWithSignature("dangerousDelegatecall(address,bytes)", address(0x1), "");
        calls[0] = TraceAnalyzer.analyzeCall(
            address(this),
            address(vulnerableContract),
            0,
            delegatecallData,
            50000,
            true
        );
        calls[0].callType = TraceAnalyzer.CallType.DELEGATECALL;
        
        // Unchecked call
        bytes memory uncheckedData = abi.encodeWithSignature("unsafeCall(address,bytes)", address(0x1), "");
        calls[1] = TraceAnalyzer.analyzeCall(
            address(this),
            address(vulnerableContract),
            1 ether,
            uncheckedData,
            50000,
            false
        );
        calls[1].callType = TraceAnalyzer.CallType.CALL;
        
        StateDiffAnalyzer.StateDiff memory stateDiff;
        stateDiff.storageChanges = new StateDiffAnalyzer.StorageChange[](1);
        stateDiff.storageChanges[0] = StateDiffAnalyzer.recordStorageChange(
            address(vulnerableContract),
            bytes32(uint256(0)),
            bytes32(0),
            bytes32(uint256(1))
        );
        
        VulnerabilityDetector.VulnerabilityReport memory report = VulnerabilityDetector.analyzeVulnerabilities(
            calls,
            stateDiff
        );
        
        assertGt(report.totalIssues, 0);
        assertGt(report.criticalCount, 0); // Should detect delegatecall
    }
    
    function testSafeContractNoVulnerabilities() public {
        vm.deal(address(this), 10 ether);
        safeContract.deposit{value: 1 ether}();
        
        TraceAnalyzer.CallInfo[] memory calls = new TraceAnalyzer.CallInfo[](1);
        
        bytes memory data = abi.encodeWithSignature("deposit()");
        calls[0] = TraceAnalyzer.analyzeCall(
            address(this),
            address(safeContract),
            1 ether,
            data,
            65000,
            true
        );
        calls[0].callType = TraceAnalyzer.CallType.CALL;
        
        StateDiffAnalyzer.StateDiff memory stateDiff;
        stateDiff.storageChanges = new StateDiffAnalyzer.StorageChange[](1);
        stateDiff.storageChanges[0] = StateDiffAnalyzer.recordStorageChange(
            address(safeContract),
            keccak256(abi.encode(address(this), uint256(0))),
            bytes32(0),
            bytes32(uint256(1 ether))
        );
        
        VulnerabilityDetector.VulnerabilityReport memory report = VulnerabilityDetector.analyzeVulnerabilities(
            calls,
            stateDiff
        );
        
        // Safe contract should have fewer or no critical vulnerabilities
        assertEq(report.criticalCount, 0);
    }
}
