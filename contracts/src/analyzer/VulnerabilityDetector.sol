// SPDX-License-Identifier: MIT
pragma solidity ^0.8.23;

import "./TraceAnalyzer.sol";
import "./StateDiffAnalyzer.sol";

/**
 * @title VulnerabilityDetector
 * @notice Detects common smart contract vulnerabilities in transaction traces
 * @dev Implements rule-based detection for reentrancy, access control, and other issues
 */
library VulnerabilityDetector {
    using TraceAnalyzer for TraceAnalyzer.CallInfo[];

    /// @notice Severity levels for vulnerabilities
    enum Severity {
        INFO,
        LOW,
        MEDIUM,
        HIGH,
        CRITICAL
    }

    /// @notice A detected vulnerability
    struct Vulnerability {
        string id;
        string name;
        Severity severity;
        string description;
        string recommendation;
        address[] affectedContracts;
        bytes4[] affectedFunctions;
        uint256 occurrenceCount;
    }

    /// @notice Complete vulnerability analysis
    struct VulnerabilityReport {
        Vulnerability[] vulnerabilities;
        uint256 totalIssues;
        uint256 criticalCount;
        uint256 highCount;
        uint256 mediumCount;
        uint256 lowCount;
    }

    /**
     * @notice Analyzes a transaction trace for vulnerabilities
     * @param calls Array of call information
     * @param stateDiff The state diff analysis
     * @return report Complete vulnerability report
     */
    function analyzeVulnerabilities(
        TraceAnalyzer.CallInfo[] memory calls,
        StateDiffAnalyzer.StateDiff memory stateDiff
    ) internal pure returns (VulnerabilityReport memory report) {
        uint256 vulnCount = 0;
        Vulnerability[] memory temp = new Vulnerability[](20);
        
        // Check for reentrancy
        Vulnerability memory reentrancy = detectReentrancy(calls, stateDiff);
        if (reentrancy.occurrenceCount > 0) {
            temp[vulnCount++] = reentrancy;
        }
        
        // Check for unchecked external calls
        Vulnerability memory uncheckedCalls = detectUncheckedCalls(calls);
        if (uncheckedCalls.occurrenceCount > 0) {
            temp[vulnCount++] = uncheckedCalls;
        }
        
        // Check for dangerous delegatecall
        Vulnerability memory delegatecall = detectDangerousDelegatecall(calls);
        if (delegatecall.occurrenceCount > 0) {
            temp[vulnCount++] = delegatecall;
        }
        
        // Check for access control issues
        Vulnerability memory accessControl = detectAccessControlIssues(calls, stateDiff);
        if (accessControl.occurrenceCount > 0) {
            temp[vulnCount++] = accessControl;
        }
        
        // Check for integer overflow/underflow (state-based)
        Vulnerability memory overflow = detectIntegerOverflow(stateDiff);
        if (overflow.occurrenceCount > 0) {
            temp[vulnCount++] = overflow;
        }
        
        // Allocate final array
        report.vulnerabilities = new Vulnerability[](vulnCount);
        for (uint256 i = 0; i < vulnCount; i++) {
            report.vulnerabilities[i] = temp[i];
            
            // Count by severity
            if (temp[i].severity == Severity.CRITICAL) {
                report.criticalCount++;
            } else if (temp[i].severity == Severity.HIGH) {
                report.highCount++;
            } else if (temp[i].severity == Severity.MEDIUM) {
                report.mediumCount++;
            } else if (temp[i].severity == Severity.LOW) {
                report.lowCount++;
            }
        }
        
        report.totalIssues = vulnCount;
    }

    /**
     * @notice Detects reentrancy patterns
     * @param calls Array of call information
     * @param stateDiff The state diff
     * @return vuln The detected reentrancy vulnerability
     */
    function detectReentrancy(
        TraceAnalyzer.CallInfo[] memory calls,
        StateDiffAnalyzer.StateDiff memory stateDiff
    ) internal pure returns (Vulnerability memory vuln) {
        vuln.id = "REENTRANCY";
        vuln.name = "Potential Reentrancy";
        vuln.severity = Severity.HIGH;
        vuln.description = "External call followed by state change detected";
        vuln.recommendation = "Apply checks-effects-interactions pattern. Update state before external calls.";
        
        address[] memory affected = new address[](calls.length);
        bytes4[] memory functions = new bytes4[](calls.length);
        uint256 count = 0;
        
        // Look for pattern: external call -> state change to same contract
        for (uint256 i = 0; i < calls.length - 1; i++) {
            if (calls[i].callType == TraceAnalyzer.CallType.CALL && 
                calls[i].value > 0) {
                // Check if next operation modifies state of the same contract
                address callTarget = calls[i].to;
                
                for (uint256 j = 0; j < stateDiff.storageChanges.length; j++) {
                    if (stateDiff.storageChanges[j].contractAddress == callTarget &&
                        i < calls.length - 1) {
                        // Potential reentrancy detected
                        bool found = false;
                        for (uint256 k = 0; k < count; k++) {
                            if (affected[k] == callTarget) {
                                found = true;
                                break;
                            }
                        }
                        if (!found) {
                            affected[count] = callTarget;
                            functions[count] = calls[i].selector;
                            count++;
                        }
                    }
                }
            }
        }
        
        vuln.occurrenceCount = count;
        vuln.affectedContracts = new address[](count);
        vuln.affectedFunctions = new bytes4[](count);
        
        for (uint256 i = 0; i < count; i++) {
            vuln.affectedContracts[i] = affected[i];
            vuln.affectedFunctions[i] = functions[i];
        }
    }

    /**
     * @notice Detects unchecked external calls
     * @param calls Array of call information
     * @return vuln The detected vulnerability
     */
    function detectUncheckedCalls(
        TraceAnalyzer.CallInfo[] memory calls
    ) internal pure returns (Vulnerability memory vuln) {
        vuln.id = "UNCHECKED_CALL";
        vuln.name = "Unchecked External Call";
        vuln.severity = Severity.MEDIUM;
        vuln.description = "External call result not checked";
        vuln.recommendation = "Always check return values of external calls or use low-level call patterns with proper error handling";
        
        address[] memory affected = new address[](calls.length);
        bytes4[] memory functions = new bytes4[](calls.length);
        uint256 count = 0;
        
        for (uint256 i = 0; i < calls.length; i++) {
            if (calls[i].callType == TraceAnalyzer.CallType.CALL &&
                !calls[i].success &&
                calls[i].value > 0) {
                // Failed call with value sent - should be checked
                affected[count] = calls[i].to;
                functions[count] = calls[i].selector;
                count++;
            }
        }
        
        vuln.occurrenceCount = count;
        vuln.affectedContracts = new address[](count);
        vuln.affectedFunctions = new bytes4[](count);
        
        for (uint256 i = 0; i < count; i++) {
            vuln.affectedContracts[i] = affected[i];
            vuln.affectedFunctions[i] = functions[i];
        }
    }

    /**
     * @notice Detects dangerous delegatecall usage
     * @param calls Array of call information
     * @return vuln The detected vulnerability
     */
    function detectDangerousDelegatecall(
        TraceAnalyzer.CallInfo[] memory calls
    ) internal pure returns (Vulnerability memory vuln) {
        vuln.id = "DELEGATECALL";
        vuln.name = "Dangerous Delegatecall";
        vuln.severity = Severity.CRITICAL;
        vuln.description = "Delegatecall detected - ensure proper access control and target validation";
        vuln.recommendation = "Delegatecall executes code in the context of the calling contract. Ensure target is trusted and access-controlled.";
        
        address[] memory affected = new address[](calls.length);
        bytes4[] memory functions = new bytes4[](calls.length);
        uint256 count = 0;
        
        for (uint256 i = 0; i < calls.length; i++) {
            if (calls[i].callType == TraceAnalyzer.CallType.DELEGATECALL) {
                affected[count] = calls[i].to;
                functions[count] = calls[i].selector;
                count++;
            }
        }
        
        vuln.occurrenceCount = count;
        vuln.affectedContracts = new address[](count);
        vuln.affectedFunctions = new bytes4[](count);
        
        for (uint256 i = 0; i < count; i++) {
            vuln.affectedContracts[i] = affected[i];
            vuln.affectedFunctions[i] = functions[i];
        }
    }

    /**
     * @notice Detects access control issues
     * @param calls Array of call information
     * @param stateDiff The state diff
     * @return vuln The detected vulnerability
     */
    function detectAccessControlIssues(
        TraceAnalyzer.CallInfo[] memory calls,
        StateDiffAnalyzer.StateDiff memory stateDiff
    ) internal pure returns (Vulnerability memory vuln) {
        vuln.id = "ACCESS_CONTROL";
        vuln.name = "Potential Access Control Issue";
        vuln.severity = Severity.MEDIUM;
        vuln.description = "State modification without apparent access control check";
        vuln.recommendation = "Ensure all state-changing functions have proper access control modifiers (onlyOwner, onlyRole, etc.)";
        
        // This is a simplified check - in production, would analyze function selectors
        // and check for access control patterns
        uint256 count = 0;
        address[] memory affected = new address[](stateDiff.storageChanges.length);
        
        for (uint256 i = 0; i < stateDiff.storageChanges.length; i++) {
            // Check if storage change corresponds to a call without access control pattern
            // This is heuristic-based - real implementation would need ABI analysis
            bool found = false;
            for (uint256 j = 0; j < count; j++) {
                if (affected[j] == stateDiff.storageChanges[i].contractAddress) {
                    found = true;
                    break;
                }
            }
            if (!found) {
                affected[count++] = stateDiff.storageChanges[i].contractAddress;
            }
        }
        
        vuln.occurrenceCount = count;
        vuln.affectedContracts = new address[](count);
        for (uint256 i = 0; i < count; i++) {
            vuln.affectedContracts[i] = affected[i];
        }
    }

    /**
     * @notice Detects potential integer overflow/underflow
     * @param stateDiff The state diff
     * @return vuln The detected vulnerability
     */
    function detectIntegerOverflow(
        StateDiffAnalyzer.StateDiff memory stateDiff
    ) internal pure returns (Vulnerability memory vuln) {
        vuln.id = "INTEGER_OVERFLOW";
        vuln.name = "Potential Integer Overflow/Underflow";
        vuln.severity = Severity.LOW; // Solidity 0.8+ has built-in checks
        vuln.description = "Large state changes detected - verify overflow protection";
        vuln.recommendation = "Solidity 0.8+ includes automatic overflow checks. For older versions, use SafeMath.";
        
        uint256 count = 0;
        address[] memory affected = new address[](stateDiff.balanceChanges.length);
        
        // Check for suspiciously large balance changes
        for (uint256 i = 0; i < stateDiff.balanceChanges.length; i++) {
            uint256 absDelta = stateDiff.balanceChanges[i].delta >= 0
                ? uint256(stateDiff.balanceChanges[i].delta)
                : uint256(-stateDiff.balanceChanges[i].delta);
            
            // Flag very large changes (heuristic)
            if (absDelta > type(uint128).max) {
                bool found = false;
                for (uint256 j = 0; j < count; j++) {
                    if (affected[j] == stateDiff.balanceChanges[i].account) {
                        found = true;
                        break;
                    }
                }
                if (!found) {
                    affected[count++] = stateDiff.balanceChanges[i].account;
                }
            }
        }
        
        vuln.occurrenceCount = count;
        vuln.affectedContracts = new address[](count);
        for (uint256 i = 0; i < count; i++) {
            vuln.affectedContracts[i] = affected[i];
        }
    }
}
